<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BlackPoker 8th - Entry20 最小プレー（PCブラウザ）</title>
<style>
  :root{--bg:#0f1221;--card:#1a203a;--ui:#141a2f;--line:#2c355d;--text:#e8ebff;--muted:#a9b3e6;--accent:#8ad1ff;}
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b0f1d,#0f1221 40%,#0b0f1d);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP",Meiryo,sans-serif}
  header{padding:12px 16px;border-bottom:1px solid var(--line);background:#0c1020;position:sticky;top:0;z-index:10}
  h1{font-size:18px;margin:0}
  #root{display:grid;grid-template-columns:1fr 380px;gap:12px;min-height:100vh}
  .board{padding:12px}
  .sidebar{border-left:1px solid var(--line);background:#0c1020;display:flex;flex-direction:column;min-height:0}
  .zone{border:1px solid var(--line);border-radius:12px;background:var(--card);padding:8px;margin-bottom:10px}
  .zone h3{font-size:13px;margin:0 0 6px;color:var(--muted);display:flex;justify-content:space-between;align-items:center}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .char{border:1px solid var(--line);border-radius:10px;padding:6px;background:#161b31;min-width:96px;min-height:120px;display:flex;align-items:center;justify-content:center}
  .char.drive{opacity:.7;transform:skewX(-6deg)}
  .char.mine{outline:1px solid #4fc3f7}
  .char.sel{box-shadow:0 0 0 2px var(--accent) inset}
  .card{border:1px solid var(--line);border-radius:8px;background:#0f152d;min-width:82px;min-height:116px;padding:4px;display:flex;align-items:center;justify-content:center;cursor:pointer}
  .card:hover{outline:2px solid var(--accent)}
  .hand{display:flex;gap:8px;flex-wrap:wrap}
  .log{flex:1;overflow:auto;padding:8px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;white-space:pre-wrap}
  .pill{padding:2px 8px;border-radius:999px;background:#101635;border:1px solid var(--line);font-size:12px}
  .header-row{display:flex;justify-content:space-between;align-items:center}
  .toprow,.bottomrow{display:grid;grid-template-columns:1fr;gap:10px;margin-bottom:10px}
  .num{font-variant-numeric:tabular-nums}
  .hint{color:#b7c0ec;font-size:12px}
  .sep{height:6px}
  button{background:#1c2442;color:var(--text);border:1px solid var(--line);padding:8px 10px;border-radius:10px;cursor:pointer}
  button.primary{background:#1c3461;border-color:#34518d}
  button:disabled{opacity:.5;cursor:not-allowed}
  img.cardimg{width:90px;height:auto;display:block}
  img.handimg{width:72px;height:auto;display:block}
</style>
</head>
<body>
<header class="header-row">
  <h1>BlackPoker 8th｜Entry20 最小プレー（2人対戦・ローカル）</h1>
  <div class="pill" id="turnInfo">準備中…</div>
</header>
<div style="padding:8px 16px;display:flex;gap:16px;align-items:center;border-bottom:1px solid var(--line);background:#0c1020;">
  <label class="hint"><input type="checkbox" id="cpuMode" checked> CPU対戦（P2がNPC）</label>
  <label class="hint" style="display:inline-flex;align-items:center;gap:6px;">難易度
    <select id="cpuLevel">
      <option value="easy">EASY</option>
      <option value="normal" selected>NORMAL</option>
      <option value="hard">HARD</option>
    </select>
  </label>
  <span class="hint">・CPUは簡易AIで行動します（防壁→召喚→攻撃→エンド）。</span>
</div>
<div id="root">
  <main class="board" id="board">
    <section class="zone">
      <h3>プレイヤー2（上） <span>ライフ:<span class="num" id="p1Life">-</span>｜手札:<span class="num" id="p1Hand">-</span>｜墓地:<span class="num" id="p1Grave">-</span></span></h3>
      <div class="toprow">
        <div>
          <div class="hint">場（上段：P2のキャラクター）</div>
          <div class="row" id="p1Field"></div>
        </div>
      </div>
    </section>
    <section class="zone">
      <h3>プレイヤー1（下・現在の手札表示） <span>ライフ:<span class="num" id="p0Life">-</span>｜手札:<span class="num" id="p0Hand">-</span>｜墓地:<span class="num" id="p0Grave">-</span></span></h3>
      <div class="bottomrow">
        <div>
          <div class="hint">場（下段：P1のキャラクター）</div>
          <div class="row" id="p0Field"></div>
        </div>
        <div>
          <div class="hint">手札（現在ターンプレイヤーのみ表示）</div>
          <div class="hand" id="hand"></div>
        </div>
      </div>
    </section>
  </main>
  <aside class="sidebar">
    <div class="zone">
      <div class="header-row">
        <h3>アクション</h3>
        <label class="hint"><input type="checkbox" id="useEntry20" checked> Entry20デッキ</label>
      </div>
      <div class="btns" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px">
        <button id="btnBulwark" class="primary">防壁設置（$L）</button>
        <button id="btnSoldier" class="primary">兵士召喚（$BL）</button>
        <button id="btnHero" class="primary">英雄召喚（$BBL）</button>
        <button id="btnAce" class="primary">エース召喚（$L）</button>
        <button id="btnAttack">アタック</button>
        <button id="btnEnd">エンド</button>
      </div>
      <div class="sep"></div>
      <div class="row">
        <button id="btnStart" class="primary">ゲーム開始</button>
        <button id="btnReset">リセット</button>
      </div>
      <div class="sep"></div>
      <div class="hint">・各アクションはクリック後に対象選択の案内が出ます。<br>・アタック→ブロック→ダメージ判定は自動で順に処理します。</div>
    </div>
    <div class="zone" style="min-height:240px;">
      <h3>ログ</h3>
      <div id="log" class="log"></div>
    </div>
  </aside>
</div>

<script>
// ========= ルール準拠の最小実装（画像カード対応版） =========
const SUIT_KEYS=["S","H","D","C"];
const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
function rankValue(r){ if(r==="A")return 1; if(r==="J")return 11; if(r==="Q")return 12; if(r==="K")return 13; if(r==="Joker")return 0; return parseInt(r,10); }

let G=null;
let CPU={enabled:true,level:'normal'};

// 画像パス生成（cards_black/<S|H|D|C>_<A|2..10|J|Q|K>.svg）
function assetPath(card){
  return `cards_black/${card.suit}_${card.rank}.svg`;
}

function buildCard(id,s,r){ return {id,suit:s,rank:r,value:rankValue(r)}; }
function buildFull54(){ const a=[]; let id=0; for(const s of SUIT_KEYS){ for(const r of RANKS){ a.push(buildCard(id++,s,r)); } } a.push(buildCard(id++,"J","Joker")); a.push(buildCard(id++,"J","Joker")); return a; }
function buildEntry20(){
  const picks=[["S",["A","2","3","4","5"]],["H",["A","8","9","10","J"]],["D",["A","3","7","10","Q"]],["C",["A","5","6","10","K"]]];
  const a=[]; let id=0; for(const [s,rs] of picks){ for(const r of rs){ a.push(buildCard(id++,s,r)); } } return a;
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]];} return a; }
function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

function newPlayer(deck){ return { life:deck.slice().reverse(), hand:[], grave:[], field:[] }; }
function log(t){ const el=document.getElementById("log"); el.textContent+=t+"\n"; el.scrollTop=el.scrollHeight; }
function cardLabel(c){ const s = {S:"♠",H:"♡",D:"♢",C:"♣"}[c.suit] || "?"; return c.rank+" "+s; }
function lifeCount(p){ return p.life.length; }
function draw(p,n=1){ const res=[]; for(let i=0;i<n;i++){ if(p.life.length===0)break; res.push(p.life.pop()); } p.hand.push(...res); return res; }
function takeDamage(p,d){ const moved=[]; for(let i=0;i<d;i++){ if(p.life.length===0)break; const top=p.life.pop(); p.grave.push(top); moved.push(top);} return moved; }
function removeFrom(arr,pred){ const i=arr.findIndex(pred); if(i>=0) return arr.splice(i,1)[0]; return null; }

let nextCharId=1;
function spawnCharacter(p,type,cards){ p.field.push({cid:nextCharId++,type,cards:deepClone(cards),drive:false,bornTurn:G.turn}); }
function charPower(ch){ return ch.type!=="bulwark" ? ch.cards.reduce((a,c)=>a+rankValue(c.rank),0) : 0; }
function isSoldier(ch){ return ch.type!=="bulwark"; }
function canAttack(ch){ return isSoldier(ch) && !ch.drive && ch.bornTurn < G.turn; }
function anyChargedBulwark(p){ return p.field.some(ch=>ch.type==="bulwark" && !ch.drive); }
function driveOneBulwark(p){ const t=p.field.find(ch=>ch.type==="bulwark" && !ch.drive); if(!t) return false; t.drive=true; return true; }

function triggerGenerationShift(p,cards){
  const targets=cards.filter(c=>["Joker","A","J","Q","K"].includes(c.rank));
  for(const _ of targets){
    while(p.life.length>0){
      const top=p.life.pop();
      if(["Joker","A","J","Q","K"].includes(top.rank)){ p.hand.push(top); break; }
      p.grave.push(top);
    }
  }
}
function toGraveFromField(p,ch){
  const idx=p.field.findIndex(x=>x.cid===ch.cid);
  if(idx>=0){ const rm=p.field.splice(idx,1)[0]; p.grave.push(...rm.cards); triggerGenerationShift(p,rm.cards); }
}
function checkWin(){
  const p0dead=G.players[0].life.length===0, p1dead=G.players[1].life.length===0;
  if(p0dead||p1dead){ const msg=p0dead&&p1dead?"引き分け！両者ライフ0":p0dead?"プレイヤー2の勝ち！(P1ライフ0)":"プレイヤー1の勝ち！(P2ライフ0)"; log("[勝敗] "+msg); G.ended=true; updateAll(); }
}

function startGame(){
  const e20=document.getElementById('useEntry20').checked;
  const d0=shuffle(e20?buildEntry20():buildFull54());
  const d1=shuffle(e20?buildEntry20():buildFull54());
  G={turn:0,current:0,step:"main",ended:false,players:[newPlayer(d0),newPlayer(d1)],attackCtx:null};

  draw(G.players[0],7); draw(G.players[1],7); log("[開始] 各プレイヤー手札7枚");
  for(let i=0;i<2;i++){ const p=G.players[i]; const bw=p.life.pop(); if(bw) spawnCharacter(p,"bulwark",[bw]); const so=p.life.pop(); if(so) spawnCharacter(p,"soldier",[so]); }
  log("[プリセット] 各プレイヤー: ライフ上から防壁→兵士を場へ");

  const a0=G.players[0].life.pop(), a1=G.players[1].life.pop();
  const v0=a0?rankValue(a0.rank):-1, v1=a1?rankValue(a1.rank):-1;
  if(a0) G.players[0].grave.push(a0); if(a1) G.players[1].grave.push(a1);
  G.current=(v1>v0)?1:0; log("[先攻] "+(G.current===0?"P1":"P2"));

  draw(G.players[G.current],1); log("[ゲーム開始] 先攻プレイヤーが1ドロー");
  G.turn=1; updateAll();
}

// ==== UI（画像カード表示） ====
function renderField(pi, mount){
  const pls=G.players[pi]; mount.innerHTML='';
  for(const ch of pls.field){
    const box=document.createElement('div'); box.className='char'+(ch.drive?' drive':'')+(pi===G.current?' mine':'');
    box.dataset.pid = pi; box.dataset.cid = ch.cid;

    const img=document.createElement('img');
    img.className='cardimg';
    if(ch.type==='bulwark'){ img.src='cards_black/back.svg'; img.alt='防壁'; }
    else { const top=ch.cards[0]; img.src=assetPath({suit:top.suit, rank:top.rank}); img.alt='兵士'; }

    box.addEventListener('click', ()=>onCharClick(pi, ch.cid, box));
    box.innerHTML=''; box.appendChild(img);
    mount.appendChild(box);
  }
}
function renderHand(){
  const hand=document.getElementById('hand'); hand.innerHTML='';
  const me=G.players[G.current];
  for(const c of me.hand){
    const el=document.createElement('div'); el.className='card'; el.dataset.id=c.id;
    const img=document.createElement('img'); img.className='handimg'; img.src=assetPath(c); img.alt=c.rank+' '+c.suit;
    el.appendChild(img);
    el.addEventListener('click', ()=>onHandClick(c));
    hand.appendChild(el);
  }
}
function updateAll(){
  if(!G) return;
  const me=G.players[G.current];
  document.getElementById('p0Life').textContent=lifeCount(G.players[0]);
  document.getElementById('p1Life').textContent=lifeCount(G.players[1]);
  document.getElementById('p0Hand').textContent=G.players[0].hand.length;
  document.getElementById('p1Hand').textContent=(CPU.enabled?'—':G.players[1].hand.length);
  document.getElementById('p0Grave').textContent=G.players[0].grave.length;
  document.getElementById('p1Grave').textContent=G.players[1].grave.length;
  document.getElementById('turnInfo').textContent=G.ended?"ゲーム終了":`T${G.turn}｜${G.current===0?"P1":"P2"}のターン｜${G.step}`;
  renderField(0,document.getElementById('p0Field'));
  renderField(1,document.getElementById('p1Field'));
  renderHand();
  const isCpuTurn=CPU.enabled&&G.current===1;
  btnBulwark.disabled=!G||G.ended||me.life.length===0||isCpuTurn;
  btnSoldier.disabled=!G||G.ended||!anyChargedBulwark(me)||!me.hand.some(c=>c.rank.match(/^[2-9]|10$/))||isCpuTurn;
  btnHero.disabled=!G||G.ended||!anyChargedBulwark(me)||me.life.length===0||!me.hand.some(c=>["J","Q","K"].includes(c.rank))||isCpuTurn;
  btnAce.disabled=!G||G.ended||me.life.length===0||!me.hand.some(c=>c.rank==="A")||isCpuTurn;
  btnAttack.disabled=!G||G.ended||!G.players[G.current].field.some(canAttack)||G.step!=="main"||isCpuTurn;
  btnEnd.disabled=!G||G.ended||isCpuTurn;
}

// ==== 入力 ====
let pending=null;
function onHandClick(card){
  if(!G||G.ended) return;
  const me=G.players[G.current];
  if(!pending) return;

  if(pending.type==='summonSoldier'){
    if(!card.rank.match(/^[2-9]|10$/)){ log("[不可] 2-10のみ"); return; }
    if(!anyChargedBulwark(me)||me.life.length<=0){ log("[不可] コスト不足"); return; }
    driveOneBulwark(me); takeDamage(me,1); removeFrom(me.hand,c=>c.id===card.id);
    spawnCharacter(me,"soldier",[card]); log(`[召喚] 兵士 ${cardLabel(card)}（$BL）`); pending=null; updateAll(); return;
  }
  if(pending.type==='summonHero'){
    if(!["J","Q","K"].includes(card.rank)){ log("[不可] J/Q/Kのみ"); return; }
    if(!anyChargedBulwark(me)||me.life.length<=0){ log("[不可] コスト不足"); return; }
    driveOneBulwark(me); if(!anyChargedBulwark(me)){ log("[不可] 2体目のB不足"); return; }
    driveOneBulwark(me); takeDamage(me,1); removeFrom(me.hand,c=>c.id===card.id);
    spawnCharacter(me,"soldier",[card]); log(`[召喚] 英雄 ${cardLabel(card)}（$BBL）`); pending=null; updateAll(); return;
  }
  if(pending.type==='summonAce'){
    if(card.rank!=="A"){ log("[不可] Aのみ"); return; }
    if(me.life.length<=0){ log("[不可] コストL不足"); return; }
    takeDamage(me,1); removeFrom(me.hand,c=>c.id===card.id);
    spawnCharacter(me,"soldier",[card]); log(`[召喚] エース ${cardLabel(card)}（$L）`); pending=null; updateAll(); return;
  }
}
function onCharClick(pi,cid,box){
  if(!G||G.ended) return;
  if(G.step==='attack'&&pi===G.current){
    const me=G.players[pi]; const ch=me.field.find(x=>x.cid===cid);
    if(!ch||!canAttack(ch)){ log("[不可] 指定不可"); return; }
    ch.__attacking=!ch.__attacking; box.classList.toggle('sel');
  }else if(G.step==='block'&&pi!==G.current){
    const op=G.players[pi]; const ch=op.field.find(x=>x.cid===cid);
    if(!ch||ch.drive){ log("[不可] ブロック不可"); return; }
    ch.__blocking=!ch.__blocking; box.classList.toggle('sel');
  }
}

// ==== ボタン ====
const btnStart=document.getElementById('btnStart');
const btnReset=document.getElementById('btnReset');
const btnBulwark=document.getElementById('btnBulwark');
const btnSoldier=document.getElementById('btnSoldier');
const btnHero=document.getElementById('btnHero');
const btnAce=document.getElementById('btnAce');
const btnAttack=document.getElementById('btnAttack');
const btnEnd=document.getElementById('btnEnd');

btnStart.onclick=()=>{ CPU.enabled=document.getElementById('cpuMode').checked; CPU.level=document.getElementById('cpuLevel').value; startGame(); if(CPU.enabled&&G.current===1) scheduleCpuTurn(); };
btnReset.onclick=()=>{ location.reload(); };
btnBulwark.onclick=()=>{ if(!G) return; const me=G.players[G.current]; if(me.life.length<=0){ log('[不可] $L不可'); return; } takeDamage(me,1); const top=me.hand.pop(); if(!top){ log('[不可] 手札空'); return; } spawnCharacter(me,'bulwark',[top]); log(`[防壁設置] ${cardLabel(top)}（$L）`); updateAll(); };
btnSoldier.onclick=()=>{ pending={type:'summonSoldier'}; log('[選択] 手札から2-10をクリック（$BL）'); };
btnHero.onclick=()=>{ pending={type:'summonHero'}; log('[選択] 手札からJ/Q/Kをクリック（$BBL）'); };
btnAce.onclick =()=>{ pending={type:'summonAce'};  log('[選択] 手札からAをクリック（$L）'); };
btnAttack.onclick=()=>{
  if(!G) return; const me=G.players[G.current];
  if(!me.field.some(canAttack)){ log('[不可] アタッカーなし'); return; }
  G.step='attack'; updateAll(); log('[選択] アタッカーをクリック→もう一度「アタック」');
  btnAttack.onclick=()=>confirmAttack();
};
function confirmAttack(){
  const me=G.players[G.current]; const attackers=me.field.filter(ch=>ch.__attacking);
  if(attackers.length===0){ log('[不可] アタッカー未指定'); G.step='main'; updateAll(); resetAttackBtn(); return; }
  for(const a of attackers){ a.drive=true; delete a.__attacking; }
  G.attackCtx={attackers:attackers.map(a=>({pid:G.current,cid:a.cid}))}; log(`[アタック] ${attackers.length} 体で攻撃！`);
  G.step='block'; updateAll(); btnAttack.disabled=true; setTimeout(()=>promptBlock(),100);
}
function promptBlock(){
  log('[選択] 防御側：ブロックするキャラクターをクリック→「エンド」で確定');
  const prev=btnEnd.onclick; btnEnd.onclick=()=>{ performDamage(); btnEnd.onclick=prev; resetAttackBtn(); };
}
function resetAttackBtn(){ btnAttack.onclick=()=>{ G.step='attack'; updateAll(); log('[選択] アタッカーを選んで再度「アタック」'); btnAttack.onclick=()=>confirmAttack(); }; }

function performDamage(){
  const atkSide=G.current, defSide=1-G.current;
  const me=G.players[atkSide], op=G.players[defSide];
  const attackers=me.field.filter(ch=>ch.drive && isSoldier(ch));
  let blockers=op.field.filter(ch=>ch.__blocking);
  if(CPU.enabled && defSide===1 && G.step==='block'){ blockers=cpuChooseBlocks(attackers,op); }
  attackers.sort((a,b)=>charPower(b)-charPower(a));
  let remaining=blockers.slice(); const results=[];
  for(const a of attackers){
    let bs=[]; const bw=remaining.find(b=>b.type==='bulwark');
    if(bw){ bs=[bw]; remaining=remaining.filter(x=>x!==bw); }
    else{ bs=pickBestBlockersFor(a,remaining); remaining=remaining.filter(b=>!bs.includes(b)); }
    if(bs.length===0){ const dmg=charPower(a); takeDamage(op,dmg); results.push(`直接 ${dmg} ダメージ`); }
    else if(bs[0].type==='bulwark'){
      const bwc=bs[0].cards[0]; const ranks=a.cards.map(c=>c.rank); const kill=(bwc.rank==='Joker')||ranks.includes(bwc.rank);
      if(kill){ toGraveFromField(me,a); results.push(`防壁(${cardLabel(bwc)})で撃退`); }
      toGraveFromField(op,bs[0]);
    }else{
      const aP=charPower(a), bP=bs.reduce((s,x)=>s+charPower(x),0);
      if(aP>bP){ for(const b of bs) toGraveFromField(op,b); }
      else if(aP<bP){ toGraveFromField(me,a); }
      else { for(const b of bs) toGraveFromField(op,b); toGraveFromField(me,a); }
    }
  }
  op.field.forEach(x=>delete x.__blocking);
  G.step='main'; updateAll(); log('[ダメージ判定] '+(results.length?results.join(' ／ '):'結果なし')); checkWin();
}

btnEnd.onclick=()=>{ if(!G) return; const me=G.players[G.current]; while(me.hand.length>7){ const d=me.hand.pop(); me.grave.push(d); log(`[手札調整] ${cardLabel(d)} を捨て札`);} endTurn(); };
function endTurn(){
  const me=G.players[G.current]; log(`[エンド] P${G.current+1} のターン終了 → チャージ`);
  me.field.forEach(ch=>ch.drive=false); draw(me,1); log(`[ドロー] P${G.current+1} が1枚引く`);
  G.current=1-G.current; G.turn++; G.step='main'; updateAll(); if(CPU.enabled&&G.current===1&&!G.ended) scheduleCpuTurn();
}

// ===== CPU =====
function scheduleCpuTurn(){ setTimeout(cpuTurn,350); }
function cpuPolicy(){ if(CPU.level==='easy') return {bulwarkProb:0.5,cautious:false,order:['soldier','ace','hero']};
  if(CPU.level==='hard') return {bulwarkProb:1.0,cautious:true, order:['hero','ace','soldier']};
  return {bulwarkProb:1.0,cautious:false,order:['hero','ace','soldier']}; }

function pickBestBlockersFor(attacker,pool){
  const soldiers=pool.filter(x=>x.type!=='bulwark').sort((a,b)=>charPower(a)-charPower(b));
  const target=charPower(attacker);
  if(CPU.level==='easy'){ return soldiers.length?[soldiers[soldiers.length-1]]:[]; }
  let chosen=[],sum=0; for(const s of soldiers){ chosen.push(s); sum+=charPower(s); if(sum>=target) break; }
  if(sum>=target) return chosen; return soldiers.length?[soldiers[soldiers.length-1]]:[];
}
function cpuChooseBlocks(attackers,defender){
  const pool=defender.field.filter(ch=>!ch.drive); const res=[];
  const bw=pool.find(x=>x.type==='bulwark');
  if(CPU.level==='hard'){
    if(bw){ const best=[...attackers].sort((a,b)=>charPower(b)-charPower(a))[0];
      const ranks=best.cards.map(c=>c.rank); const bwc=bw.cards[0];
      if(bwc.rank==='Joker'||ranks.includes(bwc.rank)) res.push(bw);
    }
  }else{ if(bw) res.push(bw); }
  const avail=pool.filter(x=>x.type!=='bulwark');
  attackers.sort((a,b)=>charPower(b)-charPower(a));
  for(const a of attackers){ const pick=pickBestBlockersFor(a,avail.filter(x=>!res.includes(x))); res.push(...pick); }
  return res;
}
function cpuTurn(){
  if(!CPU.enabled||!G||G.ended||G.current!==1) return;
  const pol=cpuPolicy(); const me=G.players[1];

  // 防壁
  if(!me.field.some(ch=>ch.type==='bulwark') && me.life.length>0){
    if(Math.random() < pol.bulwarkProb){
      takeDamage(me,1); const top=me.hand.pop(); if(top){ spawnCharacter(me,'bulwark',[top]); log('[CPU] 防壁設置'); updateAll(); return scheduleCpuTurn(); }
    }
  }
  // 召喚
  const hasB=anyChargedBulwark(me);
  const trySummon=(k)=>{
    if(k==='hero'){ const c=me.hand.find(x=>['J','Q','K'].includes(x.rank));
      if(c && hasB && me.life.length>0){ if(driveOneBulwark(me)){ if(anyChargedBulwark(me)){ driveOneBulwark(me); takeDamage(me,1); removeFrom(me.hand,x=>x.id===c.id); spawnCharacter(me,'soldier',[c]); log('[CPU] 英雄召喚'); updateAll(); return true; } } } }
    if(k==='ace'){ const c=me.hand.find(x=>x.rank==='A'); if(c && me.life.length>0){ takeDamage(me,1); removeFrom(me.hand,x=>x.id===c.id); spawnCharacter(me,'soldier',[c]); log('[CPU] エース召喚'); updateAll(); return true; } }
    if(k==='soldier'){ const c=me.hand.find(x=>x.rank.match(/^[2-9]|10$/)); if(c && hasB && me.life.length>0){ driveOneBulwark(me); takeDamage(me,1); removeFrom(me.hand,x=>x.id===c.id); spawnCharacter(me,'soldier',[c]); log('[CPU] 兵士召喚'); updateAll(); return true; } }
    return false;
  };
  for(const k of pol.order){ if(trySummon(k)){ return scheduleCpuTurn(); } }

  // 攻撃
  const attackers=me.field.filter(canAttack).sort((a,b)=>charPower(b)-charPower(a));
  if(attackers.length>0){
    let go=true;
    if(pol.cautious){
      const op=G.players[0];
      const blockPow=op.field.filter(x=>!x.drive && x.type!=='bulwark').reduce((s,x)=>s+charPower(x),0);
      const atkPow=attackers.reduce((s,x)=>s+charPower(x),0);
      const hasBW=op.field.some(x=>x.type==='bulwark' && !x.drive);
      const estLoss=hasBW?2:0;
      go = (atkPow > blockPow + estLoss);
    }
    if(go){
      attackers.forEach(a=>a.drive=true); G.attackCtx={attackers:attackers.map(a=>({pid:1,cid:a.cid}))};
      G.step='block'; updateAll(); log('[CPU] アタック宣言');
      const human=G.players[0]; const blocks=cpuChooseBlocks(attackers,human); human.field.forEach(x=>x.__blocking=blocks.includes(x));
      performDamage(); if(!G.ended) return scheduleCpuTurn(); else return;
    }
  }
  // エンド
  while(me.hand.length>7){ const d=me.hand.pop(); me.grave.push(d); }
  log('[CPU] エンド'); endTurn();
}

// 初期描画
updateAll();
</script>
</body>
</html>
